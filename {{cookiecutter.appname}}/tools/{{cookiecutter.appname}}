#!/bin/bash


# 显示脚本用法帮助信息
function usage {
    cat <<EOF
Usage: $0 [options] COMMAND [command options]

Options:

    -i <inventory_path>     指定 Ansible 库存文件路径
    -h                      显示此帮助信息
    -e <ansible variables>  设置额外的变量，格式为 key=value 或 YAML/JSON,传递给 ansible-playbook
    -v                      增加 ansible-playbook 的详细程度
    -p <playbook>           运行指定的 playbook 文件，而不是默认文件
    -c <configdir>          使用指定的配置目录（也可以通过 BOSI_CFG 环境变量指定）
    -n                      模拟运行 - 不做任何更改
    -E                      回显命令 - 不实际运行

Commands:

    requirements            安装依赖
    deploy                  执行 _action 部署步骤
    conifg                  执行 _action 配置步骤
    env                     打印当前配置的环境（库存/环境变量）
    ping [pattern]          对指定主机/组执行 Ansible ping(不是 ICMP ping)，默认为 all
    exec                    在指定的 Ansible 主机组上执行任意命令
    ssh                     使用 Ansible 库存凭证/连接 SSH 到主机（需要 Ansible 2.4 或更高版本）
    list                    列出库存中的主机（需要 Ansible 2.4 或更高版本）
    rescan                  将 SSH 主机密钥扫描到 $HOME/.ssh/known_hosts
    help                    显示帮助信息
EOF
}

# 提供 bash 补全功能的词列表
function bash_completion {
cat <<EOF
-i
-p
-c
-e
-h
-v
requirements
deploy
config
ssh
ping
exec
rescan
list
env
help
EOF
}


# 选择和加载配置目录
function choose_config {
  # 检查是否通过 -i 指定了库存文件
  if [ -n "$INVENTORY" ]; then
    inventory="$INVENTORY"
  fi

  # 如果没有指定 configdir，则尝试自动选择或提示用户选择
  if [ -z "$configdir" ]; then
    if [ ! -f ~/{{cookiecutter.appname}} ]; then
      echo "Please specify config dir:"
      # 获取所有包含 hosts 的配置目录
      configdirs=($(ls /etc/{{cookiecutter.appname}}/*/hosts | xargs -L1 dirname))
      numdirs=$(echo "$configdirs" | wc -l)
      # 让用户选择配置目录
      select configdir in "${configdirs[@]}" "None of the above"; do
        if [ "$REPLY" -eq "$(($numdirs+1))" ]; then
          echo quit
        elif [ "$REPLY" -le "$numdirs" ]; then
          # 将选择保存到 ~/{{cookiecutter.appname}} 文件
          echo "configdir=$configdir" > ~/{{cookiecutter.appname}}
        else
          echo "Bad choice, try again"
          continue
        fi
        break
      done
    else
      # 从 ~/{{cookiecutter.appname}} 文件加载配置
      source ~/{{cookiecutter.appname}}
    fi
  fi

  # 仅在未通过 -i 指定库存文件时设置 inventory
  if [ -z "$inventory" ]; then
    inventory="$configdir/hosts"
  fi

  # 检查库存文件是否存在
  if [ ! -f "$inventory" ]; then
    echo "ERROR: $inventory doesn't exist" >&2; exit 1
  fi

  # 如果存在环境文件，加载它
  if [ -f $configdir/env ]; then source $configdir/env; fi

  # 加载所有 JSON 和 YAML 变量文件
  for f in $configdir/*.json $configdir/*.yml; do
    if [ -f "$f" ]; then
      EXTRA_OPTS="$EXTRA_OPTS -e @$f"
    fi
  done
}

# 从 Ansible 库存获取配置值的内部函数
function _ansible_config {
  # 使用 ansible-inventory 获取指定主机的配置，然后用 jq 解析
  _config=$(ansible-inventory -i $inventory --host $1 | jq -Mr $2 2>/dev/null)
  # 如果获取到的值不是 "null"，则输出它
  if [ $_config != "null" ];  then
    echo $_config
  fi
}

# 使用 Ansible 库存信息 SSH 到主机的内部函数
function _ssh {
  # 获取 SSH 公共参数
  local ssh_args=$(_ansible_config $1 .ansible_ssh_common_args)
  if [[ $ssh_args == "null" ]];then
      ssh_args="$ssh_args -o ControlMaster=auto -o ControlPersist=600"
  fi
  # 获取 SSH 用户名
  local ssh_user=$(_ansible_config $1 .ansible_ssh_user)
  # 获取 SSH 主机名
  local ssh_host=$(_ansible_config $1 .ansible_host)
  # 移除第一个参数（主机名）
  shift
  # 执行 SSH 连接
  ssh $ssh_args $ssh_user@$ssh_host "$@"
}


# 初始化变量
BASEDIR=/usr/share/{{cookiecutter.appname}}
VERBOSITY=          # Ansible 详细程度标志
PLAYBOOK=${BASEDIR}/ansible/site.yml  # 默认 playbook 文件路径
ECHO=               # 命令回显标志，为空表示实际执行命令
EXTRA_OPTS=         # 传递给 Ansible 命令的额外选项

# 定义短选项
SHORT_OPTS=":hi:e:p:c:v?nEj"
# The OSX getopt command doesn't support long options
# 解析命令行选项
while getopts $SHORT_OPTS optchar; do
case "${optchar}" in
    c) configdir=$OPTARG ;;
    i) INVENTORY="$OPTARG" ;;
    e) EXTRA_OPTS="$EXTRA_OPTS -e $OPTARG" ;;
    h) usage; exit 0 ;;
    p) PLAYBOOK=$OPTARG ;;
    v) VERBOSITY="$VERBOSITY --verbose"; set -x ;;
    n) EXTRA_OPTS="$EXTRA_OPTS --check" ;;
    E) ECHO=echo ;;
    *) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
esac
done



# 移除已解析的选项，保留命令和命令参数
shift $((OPTIND-1))
# 选择和加载配置
choose_config
# 导出 CONFIG_PATH 环境变量，指向配置目录的绝对路径
export CONFIG_PATH=$(realpath $configdir)

# 获取命令
ACTION=$1
# 移除命令，保留命令参数
shift
# 根据命令执行相应的操作
case "$ACTION" in
  # 清理配置文件
  (clean)
    $ECHO rm -f .config
    ;;
  # 部署
  (deploy)
    $ECHO ansible-playbook -i $inventory $EXTRA_OPTS $VERBOSITY -e _action=$ACTION "$@" $PLAYBOOK
    ;;
  # 配置
  (config)
    $ECHO ansible-playbook -i $inventory $EXTRA_OPTS $VERBOSITY -e _action=$ACTION "$@" $PLAYBOOK
    ;;
  # 安装依赖
  (requirements)
    $ECHO ansible-galaxy install -r requirements.yml -p ansible/roles-external "$@"
    ;;
  # 执行 ping 命令
  (ping)
    PING_TARGET="${1:-all}"  # 获取目标分组或主机，默认为 all
    shift
    $ECHO ansible -i $inventory $PING_TARGET -m ping $VERBOSITY "$@"
    ;;
  # 在主机组上执行命令
  (exec)
    ANSIBLE_GROUP=$1  # 获取主机组
    shift
    $ECHO ansible -i $inventory "$ANSIBLE_GROUP" -m shell -a "$@"
    ;;
  # SSH 到主机
  (ssh)
    if [ -z "$1" ]; then
        echo "ERROR: No host specified"
        exit 1
    fi
    _ssh "$@"
    ;;
  # 列出库存中的主机
  (list)
    ansible-inventory -i $inventory --list | jq -Mr '[._meta.hostvars | to_entries[] | {key: .key, value: .value.ansible_host}] | from_entries'
    ;;
  # 重新扫描 SSH 主机密钥
  (rescan)
    # 获取所有主机名
    HOSTS=$(ansible-inventory -i $inventory --list | jq -Mr '._meta.hostvars | to_entries[] | select(.value.ansible_host != null) | .value.ansible_host')
    for h in $HOSTS; do
      # 移除旧的主机密钥
      ssh-keygen -R $h
      # 获取主机的 IP 地址
      a=$(dig +short $h)
      if [ -n "$a" ]; then
        # 如果有 IP 地址，也移除旧的密钥
        ssh-keygen -R $a;
      fi
      # 将新的主机密钥添加到 known_hosts 文件
      ssh-keyscan -t rsa $h >> $HOME/.ssh/known_hosts
    done
    ;;
  # 显示环境信息
  (env)
    echo -e "$inventory\n--"
    # 显示所有以 OS_ 开头的环境变量
    env | grep OS_
    ;;
  # 生成 bash 补全
  bash-completion) bash_completion; exit 0 ;;
  # 显示帮助信息
  help) usage ;;
  # 无效命令
  (*)
    if [ -z "$ACTION" ]; then
      echo -e "ERROR: No command specified\n"
    else
      echo -e "ERROR: '$ACTION' is invalid command\n"
    fi
    usage
    exit 2
    ;;
esac
